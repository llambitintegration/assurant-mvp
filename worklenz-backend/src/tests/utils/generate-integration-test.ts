/**
 * Integration Test Template Generator
 *
 * Generates boilerplate integration tests following the INV module pattern.
 * Helps create consistent tests during Prisma migration.
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Template configuration
 */
export interface TestTemplateConfig {
  moduleName: string; // e.g., 'inv', 'projects', 'tasks'
  serviceName: string; // e.g., 'suppliers', 'components'
  entityName: string; // Singular form, e.g., 'supplier', 'component'
  entityNamePlural: string; // Plural form, e.g., 'suppliers', 'components'
  apiPath: string; // e.g., '/api/v1/inv/suppliers'
  primaryKeyField?: string; // Default: 'id'
  testDirectory?: string; // Default: src/tests/integration/{moduleName}
}

/**
 * Generate integration test file
 */
export function generateIntegrationTest(config: TestTemplateConfig): string {
  const {
    moduleName,
    serviceName,
    entityName,
    entityNamePlural,
    apiPath,
    primaryKeyField = 'id',
    testDirectory = path.join('src', 'tests', 'integration', moduleName)
  } = config;

  // Capitalize first letter for class/type names
  const EntityName = capitalize(entityName);
  const EntitiesName = capitalize(entityNamePlural);

  const template = `/**
 * Integration Tests for ${EntitiesName} API
 * Tests actual HTTP endpoints with real database connection
 *
 * Generated by generate-integration-test utility
 * Following the INV module test pattern
 */

import {
  setupIntegrationTest,
  teardownIntegrationTest,
  cleanAfterEach
} from './setup';
import {
  getRequest,
  postRequest,
  putRequest,
  deleteRequest,
  unauthenticatedRequest,
  expectSuccess,
  expectSuccessWithData,
  expectError,
  expectUnauthorized,
  expectBadRequest,
  expectNotFound,
  expectPaginatedList,
  expectListWithItems,
  expectEmptyList,
  extractCreatedId,
  TestSession
} from './helpers';
import {
  create${EntityName},
  create${EntitiesName}
} from './fixtures';

describe('${EntitiesName} API - Integration Tests', () => {
  let testSession: TestSession;
  let teamId: string;
  let userId: string;

  // Setup before all tests
  beforeAll(async () => {
    const setup = await setupIntegrationTest();
    teamId = setup.teamId;
    userId = setup.userId;

    testSession = {
      teamId,
      userId,
      email: 'test@example.com',
      teamName: 'Test Team'
    };
  });

  // Cleanup after each test
  afterEach(async () => {
    await cleanAfterEach(teamId);
  });

  // Teardown after all tests
  afterAll(async () => {
    await teardownIntegrationTest(teamId);
  });

  // ============================================================================
  // POST ${apiPath} - Create ${EntityName}
  // ============================================================================

  describe('POST ${apiPath}', () => {
    it('should create a ${entityName}', async () => {
      const ${entityName}Data = {
        name: 'Test ${EntityName}',
        // Add required fields here
      };

      const response = await postRequest('${apiPath}', testSession, ${entityName}Data);

      expectSuccess(response);
      const data = expectSuccessWithData(response);
      expect(data.name).toBe(${entityName}Data.name);
      expect(data.team_id).toBe(teamId);
    });

    it('should fail to create ${entityName} without authentication', async () => {
      const ${entityName}Data = {
        name: 'Unauthorized ${EntityName}'
      };

      const response = await unauthenticatedRequest('post', '${apiPath}')
        .send(${entityName}Data);

      expectUnauthorized(response);
    });

    it('should fail to create ${entityName} without required fields', async () => {
      const ${entityName}Data = {
        // Missing required 'name' field
      };

      const response = await postRequest('${apiPath}', testSession, ${entityName}Data);

      expectBadRequest(response);
    });

    it('should handle optional fields correctly', async () => {
      const ${entityName}Data = {
        name: 'Minimal ${EntityName}',
        // Only required fields
      };

      const response = await postRequest('${apiPath}', testSession, ${entityName}Data);

      expectSuccess(response);
      const data = expectSuccessWithData(response);
      expect(data.name).toBe(${entityName}Data.name);
    });
  });

  // ============================================================================
  // GET ${apiPath} - List ${EntitiesName}
  // ============================================================================

  describe('GET ${apiPath}', () => {
    beforeEach(async () => {
      // Create test ${entityNamePlural}
      await create${EntitiesName}(5, teamId, userId, 'List Test ${EntityName}');
    });

    it('should list all ${entityNamePlural} for the team', async () => {
      const response = await getRequest('${apiPath}', testSession);

      const result = expectPaginatedList(response, 5);
      expect(result.data.length).toBeGreaterThanOrEqual(5);
    });

    it('should support pagination with limit and offset', async () => {
      const response = await getRequest('${apiPath}?limit=2&offset=0', testSession);

      const result = expectPaginatedList(response);
      expect(result.data.length).toBeLessThanOrEqual(2);
    });

    it('should not show ${entityNamePlural} from other teams', async () => {
      const response = await getRequest('${apiPath}', testSession);

      const result = expectPaginatedList(response);
      result.data.forEach((${entityName}: any) => {
        expect(${entityName}.team_id).toBe(teamId);
      });
    });
  });

  // ============================================================================
  // GET ${apiPath}/search - Search ${EntitiesName}
  // ============================================================================

  describe('GET ${apiPath}/search', () => {
    beforeEach(async () => {
      await create${EntityName}({
        name: 'Searchable ${EntityName}',
        teamId,
        userId
      });
    });

    it('should search ${entityNamePlural} by name', async () => {
      const response = await getRequest('${apiPath}/search?q=Searchable', testSession);

      const items = expectListWithItems(response, 1);
      expect(items[0].name).toContain('Searchable');
    });

    it('should return empty results for non-matching search', async () => {
      const response = await getRequest('${apiPath}/search?q=NonExistent', testSession);

      expectEmptyList(response);
    });
  });

  // ============================================================================
  // GET ${apiPath}/:id - Get ${EntityName} by ID
  // ============================================================================

  describe('GET ${apiPath}/:id', () => {
    let ${entityName}Id: string;

    beforeEach(async () => {
      const ${entityName} = await create${EntityName}({
        name: 'Get By ID Test',
        teamId,
        userId
      });
      ${entityName}Id = ${entityName}.${primaryKeyField};
    });

    it('should get ${entityName} by ID', async () => {
      const response = await getRequest(\`${apiPath}/\${${entityName}Id}\`, testSession);

      expectSuccess(response);
      const data = expectSuccessWithData(response);
      expect(data.${primaryKeyField}).toBe(${entityName}Id);
      expect(data.name).toBe('Get By ID Test');
    });

    it('should return 404 for non-existent ${entityName}', async () => {
      const fakeId = '00000000-0000-0000-0000-000000000000';
      const response = await getRequest(\`${apiPath}/\${fakeId}\`, testSession);

      expectNotFound(response);
    });
  });

  // ============================================================================
  // PUT ${apiPath}/:id - Update ${EntityName}
  // ============================================================================

  describe('PUT ${apiPath}/:id', () => {
    let ${entityName}Id: string;

    beforeEach(async () => {
      const ${entityName} = await create${EntityName}({
        name: 'Update Test ${EntityName}',
        teamId,
        userId
      });
      ${entityName}Id = ${entityName}.${primaryKeyField};
    });

    it('should update ${entityName} details', async () => {
      const updateData = {
        name: 'Updated ${EntityName} Name'
      };

      const response = await putRequest(\`${apiPath}/\${${entityName}Id}\`, testSession, updateData);

      expectSuccess(response);
      const data = expectSuccessWithData(response);
      expect(data.name).toBe('Updated ${EntityName} Name');
    });

    it('should not allow updating team_id', async () => {
      const updateData = {
        team_id: '00000000-0000-0000-0000-000000000000'
      };

      const response = await putRequest(\`${apiPath}/\${${entityName}Id}\`, testSession, updateData);

      const data = expectSuccessWithData(response);
      expect(data.team_id).toBe(teamId); // Should remain unchanged
    });

    it('should return 404 when updating non-existent ${entityName}', async () => {
      const fakeId = '00000000-0000-0000-0000-000000000000';
      const updateData = { name: 'Updated' };

      const response = await putRequest(\`${apiPath}/\${fakeId}\`, testSession, updateData);

      expectNotFound(response);
    });
  });

  // ============================================================================
  // DELETE ${apiPath}/:id - Delete ${EntityName} (Soft Delete)
  // ============================================================================

  describe('DELETE ${apiPath}/:id', () => {
    let ${entityName}Id: string;

    beforeEach(async () => {
      const ${entityName} = await create${EntityName}({
        name: 'Delete Test ${EntityName}',
        teamId,
        userId
      });
      ${entityName}Id = ${entityName}.${primaryKeyField};
    });

    it('should soft delete a ${entityName}', async () => {
      const response = await deleteRequest(\`${apiPath}/\${${entityName}Id}\`, testSession);

      expectSuccess(response);

      // Verify ${entityName} is soft deleted (is_active = false)
      const getResponse = await getRequest(\`${apiPath}/\${${entityName}Id}\`, testSession);
      if (getResponse.status === 200) {
        const data = expectSuccessWithData(getResponse);
        expect(data.is_active).toBe(false);
      }
    });

    it('should return 404 when deleting non-existent ${entityName}', async () => {
      const fakeId = '00000000-0000-0000-0000-000000000000';
      const response = await deleteRequest(\`${apiPath}/\${fakeId}\`, testSession);

      expectNotFound(response);
    });
  });

  // ============================================================================
  // Add custom test suites here
  // ============================================================================
});
`;

  return template;
}

/**
 * Generate fixture helper file
 */
export function generateFixtureHelpers(config: TestTemplateConfig): string {
  const { entityName, entityNamePlural } = config;
  const EntityName = capitalize(entityName);
  const EntitiesName = capitalize(entityNamePlural);

  const template = `/**
 * Fixture Helpers for ${EntitiesName}
 * Generated by generate-integration-test utility
 */

import { getPrismaClient } from './setup';

// ============================================================================
// ${EntityName} Fixtures
// ============================================================================

export interface Create${EntityName}Data {
  name: string;
  // Add other fields here
  teamId: string;
  userId: string;
}

/**
 * Create a ${entityName} in the database
 */
export async function create${EntityName}(data: Create${EntityName}Data) {
  const prisma = getPrismaClient();

  return await prisma.${entityNamePlural}.create({
    data: {
      name: data.name,
      // Map other fields here
      team_id: data.teamId,
      created_by: data.userId
    }
  });
}

/**
 * Create multiple ${entityNamePlural} in the database
 */
export async function create${EntitiesName}(
  count: number,
  teamId: string,
  userId: string,
  namePrefix: string = 'Test ${EntityName}'
) {
  const ${entityNamePlural} = [];

  for (let i = 1; i <= count; i++) {
    const ${entityName} = await create${EntityName}({
      name: \`\${namePrefix} \${i}\`,
      // Add other fields with test values
      teamId,
      userId
    });
    ${entityNamePlural}.push(${entityName});
  }

  return ${entityNamePlural};
}
`;

  return template;
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Write generated test file to disk
 */
export function writeTestFile(
  config: TestTemplateConfig,
  outputPath?: string
): string {
  const {
    moduleName,
    serviceName,
    testDirectory = path.join('src', 'tests', 'integration', moduleName)
  } = config;

  const testContent = generateIntegrationTest(config);
  const fileName = `${serviceName}.integration.spec.ts`;
  const filePath = outputPath || path.join(process.cwd(), testDirectory, fileName);

  // Ensure directory exists
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(filePath, testContent, 'utf-8');

  console.log(`[TEST GENERATOR] Created integration test: ${filePath}`);

  return filePath;
}

/**
 * Write generated fixture file to disk
 */
export function writeFixtureFile(
  config: TestTemplateConfig,
  outputPath?: string
): string {
  const {
    moduleName,
    testDirectory = path.join('src', 'tests', 'integration', moduleName)
  } = config;

  // Check if fixtures.ts already exists
  const fixturesPath = outputPath || path.join(process.cwd(), testDirectory, 'fixtures.ts');

  if (fs.existsSync(fixturesPath)) {
    console.log(`[TEST GENERATOR] Fixtures file already exists: ${fixturesPath}`);
    console.log(`[TEST GENERATOR] Add the following to your fixtures.ts:`);
    console.log('\n' + generateFixtureHelpers(config));
    return fixturesPath;
  }

  const fixtureContent = generateFixtureHelpers(config);

  // Ensure directory exists
  const dir = path.dirname(fixturesPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(fixturesPath, fixtureContent, 'utf-8');

  console.log(`[TEST GENERATOR] Created fixture helpers: ${fixturesPath}`);

  return fixturesPath;
}

/**
 * Generate full test suite (test + fixtures)
 */
export function generateTestSuite(config: TestTemplateConfig): {
  testFile: string;
  fixtureFile: string;
} {
  const testFile = writeTestFile(config);
  const fixtureFile = writeFixtureFile(config);

  console.log('\n[TEST GENERATOR] Test suite generated successfully!');
  console.log('\nNext steps:');
  console.log('1. Update fixture helpers with actual field mappings');
  console.log('2. Add custom test cases as needed');
  console.log('3. Run tests: npm run test:integration');

  return { testFile, fixtureFile };
}

/**
 * CLI entry point
 */
export function main() {
  const args = process.argv.slice(2);

  if (args.length < 4) {
    console.log('Usage: ts-node generate-integration-test.ts <moduleName> <serviceName> <entityName> <apiPath>');
    console.log('Example: ts-node generate-integration-test.ts inv suppliers supplier /api/v1/inv/suppliers');
    process.exit(1);
  }

  const [moduleName, serviceName, entityName, apiPath] = args;
  const entityNamePlural = serviceName; // Assume service name is plural form

  const config: TestTemplateConfig = {
    moduleName,
    serviceName,
    entityName,
    entityNamePlural,
    apiPath
  };

  generateTestSuite(config);
}

// Run if executed directly
if (require.main === module) {
  main();
}
